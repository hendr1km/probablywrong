{
  "hash": "753f0f2af2e623601211e074713ae4d2",
  "result": {
    "markdown": "---\ntitle: 'Exploring frequency weights in logistic regression'\ndate: '2024-06-04'\ncategories: ['R', 'modelling']\ndescription: 'Frequency weights can be used in logistic regression to address class imbalance caused by sampling bias. In this post, we will use simulations to explore how to effectively choose weights and visually understand the benefits of this approach.'\nexecute: \n  freeze: auto\n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\nknitr:\n  opts_chunk:\n    dev: png\n    dev.args:\n      bg: transparent\nimage: weight.png\n---\n\n::: {.cell}\n\n:::\n\n\nIn logistic regression, we estimate a linear model for the log odds of observing an event at different levels of our predictor. These log odds can be transformed into probabilities, which then produce the characteristic S-curve.\n\nIn essence, it all comes down to odds. Having odds of 1:1 in our underlying data generation process means that both events are equally likely to occur, each with a probability of 50%.\nOur fictional population for the simulation follows this setup, with the probabilities of our events depending on values from normal distributions for both groups, with means of 5 and 8 and standard deviations of 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n    a <- tibble(value = rnorm(4000, 5, 1), condition = \"a\")\n    b <- tibble(value = rnorm(4000, 8, 1), condition = \"b\")\n    df_ab <- bind_rows(a, b)\n\ndf_ab %>%\n  ggplot(aes(x = value, y = condition, fill = condition))+\n  ggdist::stat_halfeye()+ \n  scale_x_continuous(breaks = seq(1,12,1))+\n  blog_theme()+\n  guides(fill = \"none\")\n```\n\n::: {.cell-output-display}\n![](logistic_sim_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n## Simulating imbalance\n\n\nTo get an idea of how frequency weights affect the logistic regression results, we will generate some simulations from our fictitious population under different conditions. Each simulation will consist of 400 samples, with each N = 400 values drawn from our population. \n\n1. **Balanced dataset:** Each sample will have a 1:1 ratio of our two classes and represent the proportions in the population.\n\n2. **Unbalanced dataset:** Each sample will have a 1:4 ratio, representing an imbalance between the classes caused by some sort of sampling bias, where where one group is underrepresented in the sample, compared to the population.\n\n3. **Weighted unbalanced dataset:** Similar to the unbalanced dataset, but here each observation in the underrepresented class is given a weight of 4 to counteract the imbalance.\n\nFor each sample under these conditions we will run a logistic regression using the `logistic_sim` function on each sample.\n\nWe will then compute the median of the estimated parameters (e.g. coefficients and intercepts) from each condition in order to obtain a robust measure of central tendency.\n\nFinally, we will aggregate these median parameter estimates across all conditions into a single logistic regression model for each condition. \n\n\n::: {.panel-tabset}\n\n## logistic_sim function \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogistic_sim <- function(sample_n, a_n, b_n, a_mean = 5, b_mean = 8, a_std = 1, b_std = 1, weight = 1){\n  map(1:sample_n, ~ {\n    # Create samples for conditions a and b\n    a <- tibble(value = rnorm(a_n, a_mean, a_std), condition = 0)\n    b <- tibble(value = rnorm(b_n, b_mean, b_std), condition = 1)\n    df_ab <- bind_rows(a, b)\n\n    # Adjust weights if the argument is given and not 1 \n    if (weight != 1){\n      df_ab <- df_ab %>%\n        mutate(weights = ifelse(condition == 0, weight, 1))\n    }\n\n    return(df_ab)\n  }) %>%\n  imap(~ {\n    if (weight != 1) {\n      # Fit model with weights\n      model <- glm(condition ~ value, family = binomial, data = .x, weights = .x$weights)\n    } else {\n      # Fit model without weights\n      model <- glm(condition ~ value, family = binomial, data = .x)\n    }\n    # Tidy and return the model coefficients with iteration number\n    broom::tidy(model) %>%\n      select(term, estimate) %>%\n      mutate(iteration = .y)\n  }) %>%\n  bind_rows() %>%\n  pivot_wider(names_from = term, values_from = estimate) %>%\n  rename(alpha = `(Intercept)`, beta = value)\n}\n```\n:::\n\n\n## conditions \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndoParallel::registerDoParallel(cores = parallel::detectCores())\n\nbalanced_estimates <- logistic_sim(400, a_n = 200, b_n = 200) %>%\n  mutate(model = \"balanced\")\nunbalanced_estimates <- logistic_sim(400, a_n = 67, b_n = 333) %>%\n  mutate(model = \"unbalanced\")\nweighted_estimates <- logistic_sim(400, a_n = 67, b_n = 333, weight = 4) %>%\n  mutate(model = \"weighted\")\n```\n:::\n\n:::\n\nAs we can see, the unbalanced model underestimates the first group compared to the balanced model. It seems that the intercept is particularly affected, while the slope is relatively similar. However, all the estimated probabilities are affected.\n\nAssuming that our balanced model is the closest estimate we can get of our population, the unbalanced model that used weights seems to be better fitted. Assuming that our two events are generally equally likely to occur in our population, but our sample is biased, we might be interested in adjusting these estimates using frequency weights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_rows(balanced_estimates, unbalanced_estimates, weighted_estimates) %>%\ngroup_by(model) %>%\nsummarise(alpha.median = median(alpha),\n            beta.median = median(beta)) %>%\n  mutate(x = list(seq(3,9,.1))) %>%\n  unnest(x) %>%\n  mutate(y = boot::inv.logit(alpha.median + beta.median * x)) %>%\n  ggplot(aes(x = x, y = y, col = model))+\n  geom_line()+\n  xlab(\"value\")+\n  ylab(\"probability\")+\n  blog_theme()\n```\n\n::: {.cell-output-display}\n![](logistic_sim_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n## Relationship between odds and weights\n\nBut how do we determine an appropriate frequency weight?\n\nTo explore this, we experiment with all possible combinations of odds and weights from 1 to 20 in our fictional population. Again, we use the `logistic_sim` function to estimate our median parameters under each combination.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_n = 400\nodds = 1:20\na_n = round(sample_n / (odds + 1))\nb_n = 400 - a_n\nweight = list(1:20)\n\nsim_models <- tibble(sample_n, odds, a_n, b_n, weight) %>%\n  unnest(weight)\n\npsych::headTail(sim_models)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  sample_n odds a_n b_n weight\n1      400    1 200 200      1\n2      400    1 200 200      2\n3      400    1 200 200      3\n4      400    1 200 200      4\n5      ...  ... ... ...    ...\n6      400   20  19 381     17\n7      400   20  19 381     18\n8      400   20  19 381     19\n9      400   20  19 381     20\n```\n:::\n:::\n\n\n```{{r}}\n\ndoParallel::registerDoParallel(cores = parallel::detectCores())\n\nmodel_estimates <- sim_models %>%\n  mutate(estimates = pmap(list(sample_n = sample_n, a_n = a_n, b_n = b_n, weight = weight), logistic_sim, .progress = TRUE))\n\n```\n\n\n::: {.cell}\n\n:::\n\n\n\n## Evaluating parameter estimates for different odds and weights\n\nWe can evaluate the performance of each model by looking at the median error at different values of our variable of interest - the mean of the two groups and the midpoint between these means. As you can see in the graph, at the critical value of 6.5, the median error tends to decrease up to a certain weight threshold, after which it increases again. So even in such a simple example, weights only help to a certain extent and must be used with caution. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\npred <- model_estimates %>%\n  unnest(estimates) %>%\n  group_by(odds, a_n, b_n, weight) %>%\n  summarise(alpha.median = median(alpha),\n            beta.median = median(beta)) %>%\n  ungroup() %>%\n  mutate(x = list(c(5, 6.5, 8))) %>%\n  unnest(x) %>%\n  mutate(y = boot::inv.logit(alpha.median + beta.median * x))\n\nbench <- pred %>%\n  filter(weight == 1, odds == 1) %>%\n  select(x, y_bench = y)\n\npred_bench <- pred %>%\n  left_join(bench, by = join_by(x)) %>%\n  mutate(median_error = abs(y_bench - y)) \n\npred_min <- pred_bench %>%\n  filter(x == 6.5) %>%\n  group_by(odds) %>%\n  filter(median_error == min(median_error)) %>%\n  select(odds, weight)\n\npred_bench %>%\n  # mutate(odds = as.character(paste0(\"1:\",odds))) %>%\n  ggplot(aes(x = weight, y = median_error, col = factor(x)))+\n  geom_line()+\n  facet_wrap(~odds)+\n  blog_theme()+\n  geom_vline(data = pred_min, aes(xintercept = weight), size = 1, color = \"gray\", linetype= \"dotted\")+\n  ylab(\"median error\")+\n  labs(col = \"value\")\n```\n\n::: {.cell-output-display}\n![](logistic_sim_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n## Choosing weights\n\nThe threshold with the most balanced estimates seems to be closely related to the odds ratio. Thus, choosing the assumed imbalance of the odds as the weight may be the most appropriate, especially for smaller imbalances. At least in our simple setup. However, deviations for higher imbalances may also be due to the uncertainty of the estimates as the sample size for the minority group decreases. As the odds increase, almost any weight seems to produce more appropriate estimates than the unbalanced model where we did not adjust for sampling bias.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nno_weight_bench <- pred_bench %>%\n  filter(weight == 1) %>%\n  select(odds, x, median_error_nw = median_error)\n\npred_nh <- pred_bench %>%\n  left_join(no_weight_bench, by = join_by(odds, x), relationship = \"many-to-many\") %>%\n  mutate(improvement = ifelse(median_error <= median_error_nw, TRUE, FALSE))\n\npred_min_error <- pred_bench %>%\n  group_by(x, odds) %>%\n  filter(median_error == min(median_error)) %>%\n  select(x, odds, weight) %>%\n  mutate(best_weight = weight) %>%\n  ungroup()\n\npred_nh %>%\n  left_join(pred_min_error, by = join_by(odds, weight, x)) %>%\n  ggplot(aes(x = weight, y = odds))+\n  geom_tile(aes(fill = improvement ), alpha = .5)+\n  geom_line(aes(x = odds, y = odds), linetype= \"dashed\")+\n  geom_point(aes(x = best_weight, y = odds))+\n  facet_wrap(~factor(x))+\n  blog_theme()+\n  labs(fill = \"improvement to\\nunbalanced model\")\n```\n\n::: {.cell-output-display}\n![](logistic_sim_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n## Conclusion\n\nDepending on the scenario, weights may be helpful to deal with sampling bias and class imbalance that does not reflect the population (at least in a simple setup, like the one we worked with). However, they should be used with prior knowledge of the population to not overadjust the sampling bias. One solution might be to adjust the observed odds by the expected odds ratio in the population, in the group affected by the sampling bias. The natural class imbalance should also be maintained in the logistic regression unless you have good reasons not to. \n",
    "supporting": [
      "logistic_sim_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}